A drawing és a highlighter két külön scriptben van. Meg kéne oldani, hogy "egymás társaságában legyenek".
Jelenlegi változtatásaiddal a rajz egyáltalán nem jelenik meg, highlighter nélkül is.
content-script-draw.ts:
//(...)
const openDrawingsDatabase = async (): Promise<IDBDatabase> => {
  return new Promise((resolve, reject) => {
      const request = indexedDB.open('siteNotesDB');

      request.onupgradeneeded = (event: any) => {
          const db = event.target.result;

          // Ellenőrizzük, hogy az `drawings` tábla létezik-e, ha nem, hozzuk létre
          if (!db.objectStoreNames.contains('drawings')) {
              db.createObjectStore('drawings', { keyPath: 'id' });
              console.log(`Object store "${'drawings'}" created.`);
          }
      };

      request.onsuccess = () => {
          const db = request.result;

          // Ha új oldalra nyitjuk az adatbázist, ellenőrizzük újra az `drawings` táblát
          if (!db.objectStoreNames.contains('drawings')) {
              const version = db.version + 1; // Verzió emelése szükséges új tábla létrehozásához
              db.close();

              const upgradeRequest = indexedDB.open('siteNotesDB', version);
              upgradeRequest.onupgradeneeded = (upgradeEvent: any) => {
                  const upgradeDb = upgradeEvent.target.result;

                  if (!upgradeDb.objectStoreNames.contains('drawings')) {
                      upgradeDb.createObjectStore('drawings', { keyPath: 'id' });
                      console.log(`Object store "${'drawings'}" created during upgrade.`);
                  }
              };

              upgradeRequest.onsuccess = () => resolve(upgradeRequest.result);
              upgradeRequest.onerror = (event: any) => reject(event.target.error);
          } else {
              resolve(db); // Az adatbázis már tartalmazza a `'drawings'` táblát
          }
      };

      request.onerror = (event: any) => {
          reject(event.target.error);
      };
    });
};

const saveDrawingData = async (storeName: string, data: any): Promise<void> => {
  const db = await openDrawingsDatabase();
  const transaction = db.transaction(storeName, 'readwrite');
  const store = transaction.objectStore(storeName);

  // Add or update the data based on the ID
  store.put(data);
  return new Promise((resolve, reject) => {
    transaction.oncomplete = () => resolve();
    transaction.onerror = (event) => reject((event.target as IDBRequest).error);
  });
};

const saveCanvasDrawing = async () => {
  if (!canvas) return;

  const dataURL = canvas.toDataURL(); // A canvas tartalmának base64 kép formátumú mentése
  const drawingData = {
    id: window.location.href, // Az URL alapján azonosítjuk az oldalt
    data: dataURL,
  };

  await saveDrawingData('drawings', drawingData);
};

const loadCanvasDrawing = async () => {
  const db = await openDrawingsDatabase();
  const transaction = db.transaction('drawings', 'readonly');
  const store = transaction.objectStore('drawings');
  const request = store.get(window.location.href);

  request.onsuccess = () => {
    const result = request.result;
    if (result && result.data && canvas && ctx) {
      const img = new Image();
      img.src = result.data; // A mentett `base64` adat betöltése
      img.onload = () => {
        ctx!.drawImage(img, 0, 0); // A kép kirajzolása a canvas-ra
      };
    }
  };

  request.onerror = (event: any) => {
    console.error('Failed to load drawing:', event.target.error);
  };
};

window.addEventListener('load', () => {
  console.log('load event');
  setupCanvas();
  loadCanvasDrawing();
  console.log('load event end');
});

window.addEventListener('beforeunload', () => {
  saveCanvasDrawing();
});

content-script-highlighter.ts:
//(...)

const removeHighlight = async (event: MouseEvent): Promise<void> => {
  if (!isdeleteHighlighter) return; // Csak akkor működjön, ha a törlés mód aktív

  const target = event.currentTarget as HTMLElement;
  if (target.tagName.toLowerCase() !== 'mark') return; // Csak `mark` elemekre érvényes

  const parent = target.parentNode;
  const text = target.textContent || '';

  if (parent) {
    // Az eredeti szöveg visszaállítása
    const textNode = document.createTextNode(text);
    parent.replaceChild(textNode, target);

    // Az oldal tartalmának mentése
    try {
      await savePageContentToDB();
      console.log('Highlight deleted and page content updated.');
    } catch (error) {
      console.error(`Failed to save page content: ${error}`);
    }
  }
};

  // KELL MAJD A TÖBBINEK IS HASONLÓAN: HA NEM LÉTEZIK TÁBLA, HOZZA LÉTRE
  const openHighlighterDatabase = async (): Promise<IDBDatabase> => {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open('siteNotesDB');

        request.onupgradeneeded = (event: any) => {
            const db = event.target.result;

            // Ellenőrizzük, hogy az `highlighter` tábla létezik-e, ha nem, hozzuk létre
            if (!db.objectStoreNames.contains('highlighter')) {
                db.createObjectStore('highlighter', { keyPath: 'id' });
                console.log(`Object store "${'highlighter'}" created.`);
            }
        };

        request.onsuccess = () => {
            const db = request.result;

            // Ha új oldalra nyitjuk az adatbázist, ellenőrizzük újra az `highlighter` táblát
            if (!db.objectStoreNames.contains('highlighter')) {
                const version = db.version + 1; // Verzió emelése szükséges új tábla létrehozásához
                db.close();

                const upgradeRequest = indexedDB.open('siteNotesDB', version);
                upgradeRequest.onupgradeneeded = (upgradeEvent: any) => {
                    const upgradeDb = upgradeEvent.target.result;

                    if (!upgradeDb.objectStoreNames.contains('highlighter')) {
                        upgradeDb.createObjectStore('highlighter', { keyPath: 'id' });
                        console.log(`Object store "${'highlighter'}" created during upgrade.`);
                    }
                };

                upgradeRequest.onsuccess = () => resolve(upgradeRequest.result);
                upgradeRequest.onerror = (event: any) => reject(event.target.error);
            } else {
                resolve(db); // Az adatbázis már tartalmazza a `'highlighter'` táblát
            }
        };

        request.onerror = (event: any) => {
            reject(event.target.error);
        };
    });
};

const savePageContentToDB = async () => {
  // rajzeszközzel való működés
  const canvasData = saveCanvasContent();

  // Hozzunk létre egy másolatot a `document.body` tartalmáról
  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = document.body.innerHTML;

  // Az eltávolítandó elemek kiválasztása és eltávolítása
  const highlighterMenu = tempDiv.querySelector('#highlighterMenu');
  if (highlighterMenu) {
    highlighterMenu.remove();
  }

  // Más szükségtelen elemek eltávolítása (ha vannak ilyenek)
  const unwantedSelectors = ['#toolbar-shadow-host', '[id^="shadowHost"]:not(canvas)']; // A canvas elemeket bent hagyjuk
  unwantedSelectors.forEach((selector) => {
    const elements = tempDiv.querySelectorAll(selector);
    elements.forEach((el) => {
      el.remove();
    });
  });

  // Shadow DOM alatt található canvas elemek hozzáadása
  const shadowHosts = document.querySelectorAll('[id^="shadowHost"]');
  shadowHosts.forEach((shadowHost) => {
    const shadowRoot = (shadowHost as HTMLElement).shadowRoot;
    if (shadowRoot) {
      const canvases = shadowRoot.querySelectorAll('canvas');
      canvases.forEach((canvas) => {
        const clonedCanvas = canvas.cloneNode(true) as HTMLCanvasElement;
        tempDiv.appendChild(clonedCanvas);
      });
    }
  });

  // Tisztított HTML szöveg
  const cleanedHTML = tempDiv.innerHTML;

  const db = await openHighlighterDatabase();
  const transaction = db.transaction('highlighter', 'readwrite');
  const store = transaction.objectStore('highlighter');

  const pageData = {
    id: 'pageContent',
    url: window.location.href,
    content: cleanedHTML,
    canvasData, // Új mező a canvas tartalomhoz
  };

  store.put(pageData);

  return new Promise((resolve, reject) => {
    transaction.oncomplete = () => resolve(undefined);
    transaction.onerror = (event) => reject((event.target as IDBRequest).error);
  });
};

// Kiemelés létrehozása
const createHighlightElement = (text: string, color: string): HTMLElement => {
  const mark = document.createElement('mark');
  mark.textContent = text;
  mark.style.backgroundColor = color;
  mark.addEventListener('click', removeHighlight);
  mark.addEventListener('mouseenter', onHighlightMouseEnter);
  mark.addEventListener('mouseleave', onHighlightMouseLeave);
  return mark;
};

// Törlés eseménykezelő hozzáadása a `mark` elemekhez
const addRemoveHighlightEventListeners = () => {
  const highlights = document.querySelectorAll('mark');
  highlights.forEach((highlight) => {
    highlight.addEventListener('click', removeHighlight);
    highlight.addEventListener('mouseenter', onHighlightMouseEnter);
    highlight.addEventListener('mouseleave', onHighlightMouseLeave);
  });
};

// A `restorePageContent` módosítása, hogy törlés eseménykezelőket is hozzáadjon
const restorePageContent = async () => {
  const db = await openHighlighterDatabase();
  const transaction = db.transaction('highlighter', 'readonly');
  const store = transaction.objectStore('highlighter');

  const pageData = await new Promise<any>((resolve, reject) => {
    const request = store.get('pageContent');
    request.onsuccess = () => resolve(request.result);
    request.onerror = (event) => reject((event.target as IDBRequest).error);
  });

  if (pageData && pageData.url === window.location.href) {
    document.body.innerHTML = pageData.content;

    // Eseménykezelők újra hozzáadása
    addRemoveHighlightEventListeners();

    // Canvas tartalom visszaállítása
    if (pageData.canvasData) {
      restoreCanvasContent(pageData.canvasData);
    }

    console.log('Page content restored and cleaned.');
  }
};

// Új `window` esemény a törlés funkció aktiválásához
window.addEventListener('load', async () => {
  console.log('Page fully loaded. Restoring marked texts...');
  await restorePageContent();
  console.log('Marked texts have been successfully loaded.');

  // Eseménykezelők a meglévő kiemelésekhez
  addRemoveHighlightEventListeners();
});

// Rajzeszközzel való működés
const saveCanvasContent = () => {
  const canvases = document.querySelectorAll('canvas');
  const canvasData: Record<string, string> = {};
  
  canvases.forEach((canvas, index) => {
    const canvasId = canvas.id || `canvas-${index}`;
    canvasData[canvasId] = (canvas as HTMLCanvasElement).toDataURL();
  });

  return canvasData;
};

const restoreCanvasContent = (canvasData: Record<string, string>) => {
  Object.entries(canvasData).forEach(([id, dataUrl]) => {
    const canvas = document.getElementById(id) as HTMLCanvasElement;
    if (canvas) {
      const ctx = canvas.getContext('2d');
      const img = new Image();
      img.onload = () => ctx?.drawImage(img, 0, 0);
      img.src = dataUrl;
    }
  });
};
